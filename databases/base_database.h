//
// Physics Simulation Program
// File: base_database.h
// Created by Tobias Sharman on 13/09/2025
//
// Description:
//   - Declaration of the base database class
//   - Contains functions for handling binary file databases in my format
//
// Copyright (c) 2025, Tobias Sharman
// Licensed under a Non-Commercial License. See LICENSE file for details
//

#ifndef PHYSICS_SIMULATION_PROGRAM_BASE_DATABASE_H
#define PHYSICS_SIMULATION_PROGRAM_BASE_DATABASE_H

#include <cstdint>
#include <string>
#include <variant>
#include <vector>

#include "core/quantities/quantity.h"

// PropertyType
//
// Enumeration of supported property types for binary files
// The enum value corresponds to a unique type identifier in binary
enum class PropertyType : std::uint8_t {
    BOOL = 0,
    INT = 1,
    DOUBLE = 2,
    QUANTITY = 3,
    STRING = 4
};

// DatabaseProperty
//
// The name (key) of a database property, its property type as described by the PropertyType enumerator, and the actual
// contents of that property
struct DatabaseProperty {
    std::string name;
    PropertyType type;
    std::variant<std::int64_t, double, bool, std::string, Quantity> value;
};

// DatabaseEntry
//
// The name (key) of a database entry (highest level in this system) and a list (vector) of its properties
struct DatabaseEntry {
    std::string name;
    std::vector<DatabaseProperty> properties;
};

// BaseDatabase
//
// A class containing some operations for usage of different databases
//
// Binary file layout: (Indenting, blank lines, and ellipses means nothing they only help with clarity)
//   [ uint16_t numberOfUnits ]            // numberOfUnits = 2 bytes
//   [ Unit 0 ]                            // serialized Unit object = 7 bytes
//   [ Unit 1 ]
//   ...
//   [ Unit (numberOfUnits-1) ]
//
//   [ Entry 0 Name length ]               // length = 2 bytes
//   [ Entry 0 Name ]                      // string format
//   [ uint32_t Entry 0 propertyCount ]    // propertyCount = 4 bytes
//       [ Property 0 Name length ]        // length = 2 bytes
//       [ Property 0 Name ]               // string format
//       [ Property 0 Type enum ]          // enum (BOOL, INT, DOUBLE, STRING, QUANTITY) = 1 byte
//       [ Property 0 Value ]              // size depends on type:
//       [ Property 1 Name length ]        //   BOOl = 1 byte
//       [ Property 1 Name ]               //   INT = 8 bytes
//       [ Property 1 Type enum ]          //   DOUBLE = 8 bytes
//       [ Property 1 Value ]              //   QUANTITY = 8 (double) + 2 (unit index) = 10 bytes
//       ...                               //   STRING = 2 (length) + length bytes
//
//   [ Entry 1 Name length ]
//   [ Entry 1 Name ]
//   [ uint32_t Entry 1 propertyCount ]
//       [ Property 0 Name length ]
//       [ Property 0 Name ]
//       [ Property 0 Type enum ]
//       [ Property 0 Value ]
//       ...
//
//   ...
//
// Notes on initialisation:
//   - Will load a binary at the filepath
//         -> For particle and material databases they databases are automatically loaded on an autogenerated path that
//            is written in a {CMAKE_SOURCE_DIR}/config/config.h file as cpp macros by a cmake function
//
// Notes on algorithms:
//   - Storage of 1 byte as minimum as parsing for nibbles or smaller types would just add overhead for the processor
//   - 2 bytes (65, 535) worth for length strings is a bit overkill as I should never have strings that long but it
//     leaves the option open for a description field that would possibly be not long enough for a 1 byte (255) limit
//   - The saveToBinary function is not used but is made to leave a future option of writing the current state of the
//     program to a file, in a small size, in the case of needing to halt the program
//   - It is not recommended to use saveToBinary as a middleman in updating the databases as the cmake function that
//     makes the database binaries will overwrite them
//
// Notes on output:
//   - Separate functions for get functions for easier implementation
//         -> Getting desired properties is recommended via more specific getters in child/derived classes
//
// Supported overloads / operations and functions / methods:
//   - Constructor:            BaseDatabase()
//   - Load from binary file:  loadFromBinary()
//   - Save to binary file:    saveToBinary()
//   - Contain check:          contains()
//   - Get property:           getStringProperty(), getNumericProperty, getQuantityProperty()
//
// Example Usage:
//   baseDatabase database{DATABASE_PATH}; // Creates instance called database; auto store the contents of DATABASE_PATH in it via loadFromBinary
//
//   bool a = database.contains("entry");  // True if it does contain entry else false
//
//   std::string b = database.getStringProperty("string property"); // Gets a string property
//   double c = database.getStringProperty("string property");      // Gets a numeric property
//   Quantity b = database.getStringProperty("string property");    // Gets a Quantity property
class BaseDatabase {
    public:
        // Constructor from string
        //
        // Loads from a binary file immediately
        explicit BaseDatabase(const std::string& filepath) {
            loadFromBinary(filepath);
        }

        // Load from binary method
        //
        // Loads a binary file at filepath into m_db
        void loadFromBinary(const std::string& filepath);

        // Save to binary method
        //
        // Saves the contents of m_db into a binary file at filepath
        void saveToBinary(const std::string& filepath);

        // Contains method
        //
        // Checks if the database m_db contains an entry entryName
        [[nodiscard]] bool contains(const std::string& entryName) const noexcept;

        // Get string property method
        //
        // Gets the value of the described property (propertyName) from the entry (entryName) for string types
        [[nodiscard]] std::string getStringProperty(const std::string& entryName, const std::string& propertyName) const;

        // Get numeric property method
        //
        // Gets the value of the described property (propertyName) from the entry (entryName) for numeric types
        [[nodiscard]] double getNumericProperty(const std::string& entryName, const std::string& propertyName) const;

        // Get Quantity property method
        //
        // Gets the value of the described property (propertyName) from the entry (entryName) for Quantity types
        [[nodiscard]] Quantity getQuantityProperty(const std::string& entryName, const std::string& propertyName) const;

    protected:
        std::vector<DatabaseEntry> m_db;

    private:
        // Find entry method
        //
        // Searches for an entry entryName
        [[nodiscard]] const DatabaseEntry& findEntry(const std::string& entryName) const;

        // Find property method
        //
        // Searches for a property propertyName
        [[nodiscard]] static const DatabaseProperty& findProperty(const DatabaseEntry& entry, const std::string& propertyName);
};

#endif //PHYSICS_SIMULATION_PROGRAM_BASE_DATABASE_H